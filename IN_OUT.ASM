PLUS EQU  43
MINUS EQU 45
MULT EQU 42
DIVIDE EQU 47
ENTER EQU 13

CODE_SEG    SEGMENT PUBLIC
  ASSUME    CS:CODE_SEG

  PUBLIC REG_OUT 

;AX REGISTER VALUE OUTPUT IN DECIMAL
REG_OUT PROC NEAR

  PUSH AX
  PUSH BX
  PUSH CX
  PUSH DX
  
  XOR CX,CX
  MOV BX, 10
L1:
  XOR DX,DX
  DIV BX
  PUSH DX
  INC CX
  TEST AX,AX
  JNZ L1

PRINT_LOOP:
  POP DX
  ADD DX,48
  
  MOV       AH,2
  INT       21h
  
  LOOP      PRINT_LOOP
  POP DX
  POP CX
  POP BX
  POP AX
  RET
  
REG_OUT     ENDP

  
;KEYBOARD INPUT 0-9 OR +-/ENTER. OUTPUT AL = ASCII AH, = OP CODE (+,10;-,11;*,12;/,13;ENTER,14;) 
  PUBLIC INPUT_NUM 

INPUT_NUM PROC NEAR
  PUSH BX
  PUSH CX
  PUSH DX  

INPUT:  
  MOV AH, 0
  INT 16h
  CMP AL, PLUS
  JZ PLUS_PRESSED
  CMP AL, MINUS
  JZ MINUS_PRESSED
  CMP AL, MULT
  JZ MULT_PRESSED
  CMP AL, DIVIDE
  JZ DIVIDE_PRESSED
  CMP AL, ENTER
  JZ ENTER_PRESSED

  MOV DL, AL
  SUB DL, 48
  JS INPUT
  MOV DL, AL
  SUB DL, 58
  JNS INPUT
  MOV AH, AL
  SUB AH, 48

END_INPUT:  
  POP DX
  POP CX
  POP BX
  RET

PLUS_PRESSED:
  MOV AH, 10
  JMP END_INPUT
MINUS_PRESSED: 
  MOV AH, 11
  JMP END_INPUT
MULT_PRESSED:    
  MOV AH, 12
  JMP END_INPUT
DIVIDE_PRESSED:
  MOV AH, 13
  JMP END_INPUT
ENTER_PRESSED:
  MOV AH, 14
  JMP END_INPUT

INPUT_NUM    ENDP

  PUBLIC COMP_NUM 

;COMPILE DIGITS TO AX VALUE CX = NUMBER OF DIGITS. DIGITS FROM STACK.
COMP_NUM PROC NEAR
  POP SI
  XOR DX, DX
  
  MOV BX, 1
  
LOOP1:  
  POP AX
  PUSH DX
  MUL BX
  POP DX
  ADD DX, AX
  
  MOV AX, BX ;MULT BX BY 10 TO GO TO THE NEXT DIGIT   
  PUSH DX
  MOV DX, 10
  MUL DX
  POP DX
  MOV BX, AX
  
  LOOP LOOP1
  MOV AX, DX
  
  PUSH SI
  RET
COMP_NUM ENDP



CODE_SEG    ENDS
 END


